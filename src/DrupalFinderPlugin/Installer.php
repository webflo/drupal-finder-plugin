<?php

namespace DrupalFinderPlugin;

use Composer\Composer;
use Composer\Config;
use Composer\EventDispatcher\EventSubscriberInterface;
use Composer\IO\IOInterface;
use Composer\Package\AliasPackage;
use Composer\Package\Locker;
use Composer\Package\PackageInterface;
use Composer\Package\RootPackageInterface;
use Composer\Plugin\PluginInterface;
use Composer\Script\Event;
use Composer\Script\ScriptEvents;
use Composer\Util\Filesystem;
use Generator;
use RuntimeException;

final class Installer implements PluginInterface, EventSubscriberInterface {

  private static $generatedClassTemplate = <<<'PHP'
<?php

declare(strict_types=1);

namespace DrupalFinderPlugin;

/**
 * This class is generated by webflo/drupal-finder-plugin, specifically by
 * @see \DrupalFinderPlugin\Installer
 *
 * This file is overwritten at every run of `composer install` or `composer update`.
 */
%s
{

    /**
     * Medata about this composer project.
     *
     * Dont read this array from your calling code, but use the provided method instead.
     *
     * @var array
     *
     * @internal
     */
    const METADATA = %s;

    /**
      * vendor-dir, relative to DRUPAL_ROOT.
      *
      * @return string
      */
    public static function getVendorDir() {
      return self::METADATA['vendorDir'];
    }

    /**
      * vendor-bin-dir, relative to DRUPAL_ROOT.
      *
      * @return string
      */
    public static function getVendorBinDir() {
      return self::METADATA['vendorBinDir'];
    }

}
PHP;


  public function activate(Composer $composer, IOInterface $io)
  {
    // Nothing to do here, as all features are provided through event listeners
  }

  public function deactivate(Composer $composer, IOInterface $io)
  {
    // Nothing to do here, as all features are provided through event listeners
  }

  public function uninstall(Composer $composer, IOInterface $io)
  {
    // Nothing to do here, as all features are provided through event listeners
  }

  /**
   * {@inheritDoc}
   */
  public static function getSubscribedEvents(): array
  {
    return [ScriptEvents::POST_AUTOLOAD_DUMP => 'dumpInfoClass'];
  }

  /**
   * @throws RuntimeException
   */
  public static function dumpInfoClass(Event $composerEvent)
  {
    $composer = $composerEvent->getComposer();

    $rootPackage = $composer->getPackage();
    $versions = iterator_to_array(self::getVersions($composer->getLocker(), $rootPackage));

    if (! array_key_exists('webflo/drupal-finder-plugin', $versions)) {
      // plugin is installed globally. project-local is required. we only want
      // to generate info for projects which specifically require
      // webflo/drupal-finder-plugin
      return;
    }

    $metadata['composerRoot'] = getcwd();
    $vendorDir = $composer->getConfig()->get('vendor-dir');
    $vendorBinDir = $composer->getConfig()->get('bin-dir');

    $package = self::getRootPackageAlias($rootPackage);
    $path = getcwd();

    $extra = $package->getExtra();

    if (isset($extra['installer-paths']) && is_array($extra['installer-paths'])) {
      foreach ($extra['installer-paths'] as $install_path => $items) {
        if (in_array('type:drupal-core', $items) ||
          in_array('drupal/core', $items) ||
          in_array('drupal/drupal', $items)) {

          // @todo: Remove this magic and detect the major version instead.
          if (($install_path == 'core') || ((isset($json['name'])) && ($json['name'] == 'drupal/drupal'))) {
            $install_path = '';
          } elseif (substr($install_path, -5) == '/core') {
            $install_path = substr($install_path, 0, -5);
          }
          $drupalRoot = rtrim($path . '/' . $install_path, '/');
        }
      }
    }

    if ($drupalRoot === NULL) {
      throw new RuntimeException('Drupal root not found.');
    }

    $fs = new Filesystem();

    $metadata = [
      'vendorDir' => $fs->findShortestPath($drupalRoot, $vendorDir, TRUE),
      'vendorBinDir' => $fs->findShortestPath($drupalRoot, $vendorBinDir, TRUE),
    ];

    $infoClass = self::generateInfoClass($rootPackage->getName(), $metadata);

    self::writeInfoClassToFile($infoClass, $composer, $composerEvent->getIO());
  }

  /**
   * @param string[] $medata
   */
  private static function generateInfoClass(string $rootPackageName, array $medata): string
  {
    return sprintf(
      self::$generatedClassTemplate,
      'fin' . 'al ' . 'cla' . 'ss ' . 'Info', // note: workaround for regex-based code parsers :-(
      var_export($medata, true)
    );
  }


  /**
   * @throws RuntimeException
   */
  private static function writeInfoClassToFile(string $InfoClassSource, Composer $composer, IOInterface $io)
  {
    $installPath = self::locateRootPackageInstallPath($composer->getConfig(), $composer->getPackage()) . '/src/DrupalFinderPlugin/Info.php';

    $installDir = dirname($installPath);
    if (! file_exists($installDir)) {
      $io->write('<info>webflo/drupal-finder-plugin:</info> Package not found (probably scheduled for removal); generation of version class skipped.');

      return;
    }

    if (! is_writable($installDir)) {
      $io->write(
        sprintf(
          '<info>webflo/drupal-finder-plugin:</info> %s is not writable; generation of info class skipped.',
          $installDir
        )
      );

      return;
    }

    $io->write('<info>webflo/drupal-finder-plugin:</info> Generating info class...');

    $installPathTmp = $installPath . '_' . uniqid('tmp', true);
    file_put_contents($installPathTmp, $InfoClassSource);
    chmod($installPathTmp, 0664);
    rename($installPathTmp, $installPath);

    $io->write('<info>webflo/drupal-finder-plugin:</info> ...done generating info class');
  }

  /**
   * @throws RuntimeException
   */
  private static function locateRootPackageInstallPath(Config $composerConfig, RootPackageInterface $rootPackage): string {
    if (self::getRootPackageAlias($rootPackage)->getName() === 'webflo/drupal-finder-plugin') {
      return dirname($composerConfig->get('vendor-dir'));
    }

    return $composerConfig->get('vendor-dir') . '/webflo/drupal-finder-plugin';
  }

  private static function getRootPackageAlias(RootPackageInterface $rootPackage): PackageInterface
  {
    $package = $rootPackage;

    while ($package instanceof AliasPackage) {
      $package = $package->getAliasOf();
    }

    return $package;
  }

  /**
   * @return Generator&string[]
   *
   * @psalm-return Generator<string, string>
   */
  private static function getVersions(Locker $locker, RootPackageInterface $rootPackage): Generator
  {
    $lockData = $locker->getLockData();

    $lockData['packages-dev'] = $lockData['packages-dev'] ?? [];

    $packages = $lockData['packages'];
    if (getenv('COMPOSER_DEV_MODE') !== '0') {
      $packages = array_merge($packages, $lockData['packages-dev']);
    }
    foreach ($packages as $package) {
      yield $package['name'] => $package['version'] . '@' . (
          $package['source']['reference'] ?? $package['dist']['reference'] ?? ''
        );
    }

    foreach ($rootPackage->getReplaces() as $replace) {
      $version = $replace->getPrettyConstraint();
      if ($version === 'self.version') {
        $version = $rootPackage->getPrettyVersion();
      }

      yield $replace->getTarget() => $version . '@' . $rootPackage->getSourceReference();
    }

    yield $rootPackage->getName() => $rootPackage->getPrettyVersion() . '@' . $rootPackage->getSourceReference();
  }

}
